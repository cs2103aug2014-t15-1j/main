//@author: a0116208n



	/**
	 * origin: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\gui\MainScreen.java
	 */

    private static void configureShell(Shell shell) {
        Display display = shell.getDisplay();
        Rectangle bounds = display.getBounds();
        int shellWidth = (int) (bounds.width * 0.8);
        int shellHeight = (int) (bounds.height * 0.8);

        shell.setSize(shellWidth, shellHeight);
        setBackGround(shell);
        setPositionToCenterOfScreen(shell);
        setLayout(shell);
    }
    
	// End of segment: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\gui\MainScreen.java





	/**
	 * origin: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\gui\SidePane.java
	 */

    private void setDimensions(Composite parent) {
        int shellWidth = parent.getSize().x;
        this.setSize((int) (shellWidth * 0.8), MIN_HEIGHT_SIDE_PANE);
    }

	// End of segment: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\gui\SidePane.java





	/**
	 * origin: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\gui\TableComposite.java
	 */

    /**
     * Adds a listener to the tab folder containing the tables. Thus the user
     * can traverse between tabs by pressing F2 and F3
     */
    private void addListener(final CTabFolder folder) {
        Display display = folder.getDisplay();
        display.addFilter(SWT.KeyDown, new Listener() {

            public void handleEvent(Event event) {
                int index = folder.getSelectionIndex();
                if (event.keyCode == SWT.F3) {
                    folder.setSelection((index + 1) % NUM_TAB_LABELS);
                } else if (event.keyCode == SWT.F2) {
                    folder.setSelection((index + NUM_TAB_LABELS - 1) %
                                        NUM_TAB_LABELS);
                }
            }
        });
    }
}

	// End of segment: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\gui\TableComposite.java





	/**
	 * origin: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\gui\TitleLabel.java
	 */

    /**
     * Creates a close button for the program.
     */
    private void createCloseButton(Composite parent) {
        Button button = new Button(parent, SWT.PUSH);
        button.setText(" X ");
        button.setCursor(new Cursor(Display.getCurrent(), SWT.CURSOR_HAND));
        button.setLayoutData(new GridData(SWT.RIGHT, SWT.TOP, false, false, 1, 1));
        
        button.addSelectionListener(new SelectionListener() {
            public void widgetSelected(SelectionEvent event) {
                System.exit(0);
            }
            
            public void widgetDefaultSelected(SelectionEvent event) {
                System.exit(0);
            }
        });
        
    }
    
	// End of segment: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\gui\TitleLabel.java





	/**
	 * origin: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\Main.java
	 */

import gui.MainScreen;

/**
 * This class contains the main method for Haystack (This is for ease of
 * execution).
 */
public class Main {

    public static void main(String[] args) {
        MainScreen.run();
    }

}

	// End of segment: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\Main.java





	/**
	 * origin: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\objects\DateTime.java
	 */

    /**
     * Compares this <code>DateTime</code> with an input <code>DateTime</code><br>
     * Returns 1 if it is later (larger) than the other <code>DateTime</code>, 0
     * if they are the same, or -1 if it is earlier (smaller).
     * 
     * @return <ul>
     *         <li>1 if this <code>DateTime</code> is later than the input
     *         <code>DateTime</code>,
     *         <li>0 if they are the same date and time,
     *         <li>-1 if this <DateTime> is earlier.
     *         </ul>
     */
    @Override
    public int compareTo(DateTime otherDateTime) {
        assert otherDateTime != null : "dateTime mustn't be null";
        assert otherDateTime.toString().matches(DATE_TIME_PATTERN) : "dateTime's attributes must have correct format and value";

        int day1 = this.day;
        int mth1 = this.month;
        int yr1 = this.year;
        int day2 = otherDateTime.day;
        int mth2 = otherDateTime.month;
        int yr2 = otherDateTime.year;

        // Check for default year values, indicating empty date values
        // Treat empty date values as later than any date value
        if (yr1 == 0 && yr2 != 0) {
            return LATER;
        } else if (yr2 == 0 && yr1 != 0) {
            return EARLIER;
        }

        // Check year for differences
        if (yr1 < yr2) {
            return EARLIER;
        } else if (yr1 > yr2) {
            return LATER;
        }

        // Then check month for differences
        if (mth1 < mth2) {
            return EARLIER;
        } else if (mth1 > mth2) {
            return LATER;
        }

        // Then check day for differences
        if (day1 < day2) {
            return EARLIER;
        } else if (day1 > day2) {
            return LATER;
        }

        // If dates are equal and time exists
        if (!this.time.isEmpty() && !otherDateTime.time.isEmpty()) {
            // Check time for differences
            int time1 = Integer.parseInt(this.time);
            int time2 = Integer.parseInt(otherDateTime.time);
            if (time1 < time2) {
                return EARLIER;
            } else if (time1 > time2) {
                return LATER;
            }
        } else if (!this.time.isEmpty()) {
            // Treat empty time value as later than any other time
            return EARLIER;
        } else if (!otherDateTime.time.isEmpty()) {
            // Treat empty time value as later than any other time
            return LATER;
        }

        // No differences detected
        return EQUAL;
    }

	// End of segment: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\objects\DateTime.java





	/**
	 * origin: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\objects\DateTime.java
	 */

    /**
     * Compares this <code>DateTime</code> with an input <code>DateTime</code>.<br>
     * Returns <code>true</code> if it is earlier than the other
     * <code>DateTime</code>.
     */
    public boolean isEarlierThan(DateTime otherDateTime) {
        assert otherDateTime != null : "dateTime mustn't be null";
        assert otherDateTime.toString().matches(DATE_TIME_PATTERN) : "dateTime's attributes must have correct format and value";
        return (this.compareTo(otherDateTime) == EARLIER);
    }

    /**
     * Compares this <code>DateTime</code> with an input <code>DateTime</code>.<br>
     * Returns <code>true</code> if it is later than the other
     * <code>DateTime</code>.
     */
    public boolean isLaterThan(DateTime otherDateTime) {
        assert otherDateTime != null : "dateTime mustn't be null";
        assert otherDateTime.toString().matches(DATE_TIME_PATTERN) : "dateTime's attributes must have correct format and value";
        return (this.compareTo(otherDateTime) == LATER);
    }

	// End of segment: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\objects\DateTime.java





	/**
	 * origin: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\objects\TaskParam.java
	 */

package objects;

/**
 * This object represents a Task Parameter, which is a pairing of a parameter
 * name and its related content (field).
 */
public class TaskParam {

    private String name = "";
    private String field = "";

    public TaskParam(String name, String field) {
        this.name = name.trim();
        this.field = field.trim();
    }

    public String getName() {
        return name;
    }

    public String getField() {
        return field;
    }

    public void setField(String str) {
        this.field = str.trim();
    }

    public void addToField(String str) {
        if (str.length() > 0) {
            this.field = this.field.concat(" " + str.trim()).trim();
        }
    }

    @Override
    public String toString() {
        return "[ " + name + " // " + field + " ]";
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }

        if (obj == null || (obj.getClass() != this.getClass())) {
            return false;
        }

        TaskParam param = (TaskParam) obj;
        return name.equals(param.getName()) && field.equals(param.getField());
    }

}

	// End of segment: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\objects\TaskParam.java





	/**
	 * origin: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\parser\DateParser.java
	 */

package parser;

import java.util.Arrays;
import java.util.Calendar;
import java.util.Scanner;
import java.text.DateFormat;
import java.text.SimpleDateFormat;

import objects.DateTime;

/**
 * The DateParser handles all date-related functions, from generating current
 * date/time Strings, checking validity of Strings as DateTimes, and parsing
 * Strings to DateTimes. It does not call any other classes' methods, but uses
 * the DateTime object.
 */
public class DateParser {

    // Date formats (i.e. inclusive of day and month only? Or with year?)
    private static final int LENGTH_DATE_LONG = 3;
    private static final int LENGTH_DATE_SHORT = 2;

    /** <i>Everything began with 1819...</i> */
    private static final int YEAR_MINIMUM = 1819;

    // Types of DateTime formats
    private static final String TYPE_TIME_DATE = "time-date";
    private static final String TYPE_DATE_TIME = "date-time";
    private static final String TYPE_TIME_ONLY = "time-only";
    private static final String TYPE_DATE_ONLY = "date-only";
    // Alternative words for numerical time/dates
    private static final String ALT_TIME_NOW = "now";
    private static final String ALT_DATE_TODAY = "today";
    private static final String ALT_DATE_TOMORROW = "tomorrow";
    private static final String ALT_DATE_TMR = "tmr";
    // List of words that substitute dates
    private static final String[] LIST_DATE_WORDS = { ALT_DATE_TODAY,
                                                     ALT_DATE_TOMORROW,
                                                     ALT_DATE_TMR };

    /** The date/time format DateParser will use. */
    private static final DateFormat FORMAT_DATE_TIME = new SimpleDateFormat(
            "dd/MM/yyyy HHmm");

    
    /** See {@link Parser#getCurrDateTime()}. */
    static DateTime getCurrDateTime() {
        Calendar cal = Calendar.getInstance();
        String[] date = FORMAT_DATE_TIME.format(cal.getTime()).split(" ");
        return new DateTime(date[0], date[1]);
    }

    /** See {@link Parser#getCurrDateTimeStr()}. */
    static String getCurrDateTimeStr() {
        return getCurrDateTime().toString();
    }

    /** See {@link Parser#getCurrTimeStr()}. */
    static String getCurrTimeStr() {
        String currDate = getCurrDateTimeStr();
        String[] dateFields = currDate.split(" ");
        return dateFields[1];
    }

    /** See {@link Parser#getCurrDateStr()}. */
    static String getCurrDateStr() {
        String currDate = getCurrDateTimeStr();
        String[] dateFields = currDate.split(" ");
        return dateFields[0];
    }

    /** See {@link Parser#getTmrDateStr()}. */
    static String getTmrDateStr() {
        String today = getCurrDateStr();
        return getNextDayStr(today);
    }

    /** See {@link Parser#getDateFromNowStr(int)}. */
    static String getDateFromNowStr(int numDaysLater) {
        String date = getCurrDateStr();
        for (int i = 0; i < numDaysLater; i++) {
            date = getNextDayStr(date);
        }
        return date;
    }

    /**
     * Returns the date one day later than the input date. Input date must be of
     * the correct <code>String</code> format.
     * 
     * @param currDay
     *            Date in "dd/MM/yyyy" format
     * @return <code>String</code> object containing date in
     *         <code>dd/MM/yyyy</code>
     */
    private static String getNextDayStr(String currDay) {
        assert isValidDate(currDay) : "input <" + currDay + "> is invalid";
        String[] dateFields = currDay.split("/");

        int day = Integer.parseInt(dateFields[0]);
        int tmr = day + 1;
        int month = Integer.parseInt(dateFields[1]);
        int year = Integer.parseInt(dateFields[2]);

        if (!isValidDay(tmr, month, year)) {
            tmr = 1;
            month++;
            if (!isValidMonth(month)) {
                month = 1;
                year++;
            }
        }

        dateFields = new String[] { toDoubleDigitStr(tmr),
                                   toDoubleDigitStr(month),
                                   Integer.toString(year) };
        String date = dateFields[0] + "/" + dateFields[1] + "/" + dateFields[2];
        return date;
    }

    /**
     * Converts an <code>int</code> to a two-character <code>String</code>, by
     * adding leading zeroes if necessary.
     */
    private static String toDoubleDigitStr(int num) {
        if (num < 10) {
            return "0" + Integer.toString(num);
        } else {
            return Integer.toString(num);
        }
    }

    /**
     * Converts an <code>int</code> to a four-character <code>String</code>, by
     * adding "20" in front if necessary.
     */
    private static String toFourDigitStr(int num) {
        assert (num >= YEAR_MINIMUM || (num >= 0 && num < 100));

        if (num < 100) {
            return "20" + Integer.toString(num);
        } else {
            return Integer.toString(num);
        }
    }

    /** Returns the current year in a four-digit String. */
    private static String getCurrYearStr() {
        String currDate = getCurrDateStr();
        String[] dateFields = currDate.split("/");
        assert (dateFields.length == 3);
        String year = dateFields[2];
        return year;
    }

    /** See {@link Parser#isValidDateTime(String)}. */
    static boolean isValidDateTime(String str) {
        String[] strFields = str.split(" ");

        boolean validNumOfTerms = strFields.length > 0 && strFields.length <= 2;
        boolean containsDate = false;
        boolean containsTime = false;
        boolean containsMultipleDates = false;
        boolean containsMultipleTimes = false;
        boolean containsNonDateTime = false;

        for (int i = 0; i < strFields.length; i++) {
            if (isValidDate(strFields[i])) {
                if (!containsDate) {
                    containsDate = true;
                } else {
                    containsMultipleDates = true;
                }
            } else if (isValidTime(strFields[i])) {
                if (!containsTime) {
                    containsTime = true;
                } else {
                    containsMultipleTimes = true;
                }
            } else {
                containsNonDateTime = true;
            }
        }

        return validNumOfTerms && (containsDate || containsTime) &&
               !(containsMultipleDates || containsMultipleTimes) &&
               !containsNonDateTime;
    }

    /** See {@link Parser#parseToDateTime(String)}. */
    static DateTime parseToDateTime(String str) {
        if (str == null || str.isEmpty()) {
            return new DateTime();
        }

        if (!isValidDateTime(str)) {
            throw new IllegalArgumentException(
                    "Invalid input for parseToDateTime");
        }

        String date = "";
        String time = "";
        String[] dateFields;
        switch (getDateType(str)) {
            case TYPE_DATE_ONLY:
                date = formatDate(str);
                break;

            case TYPE_TIME_ONLY:
                date = getCurrDateStr();
                time = formatTime(str);
                break;

            case TYPE_DATE_TIME:
                dateFields = str.split(" ");
                assert (dateFields.length == 2);
                date = formatDate(dateFields[0]);
                time = formatTime(dateFields[1]);
                break;

            case TYPE_TIME_DATE:
                dateFields = str.split(" ");
                assert (dateFields.length == 2);
                date = formatDate(dateFields[1]);
                time = formatTime(dateFields[0]);
                break;

            default:
                return new DateTime();
        }

        return new DateTime(date, time);

    }

    /**
     * Gets the date format of the input <code>String</code>. It is assumed that
     * the input has been checked and the <code>String</code> contains a valid
     * date and/or time.
     * <p>
     * Returns an <code>int</code> based on which format in the following list
     * the input corresponds to:
     * <ol>
     * <li>dd/MM/yyyy
     * <li>HHmm
     * <li>dd/MM/yyyy HHmm
     * <li>HHmm dd/MM/yyyy
     * </ol>
     * 
     * @return An integer from 1 to 4 based on which format the input
     *         corresponds to (in the above list).
     */
    private static String getDateType(String str) {
        assert (isValidDateTime(str)) : "Invalid DateTime for getDateType()!";
        String[] dateFields = str.trim().split(" ");

        if (isSingleItemArray(dateFields)) {
            if (firstItemIsDate(dateFields)) {
                return TYPE_DATE_ONLY;
            } else {
                return TYPE_TIME_ONLY;
            }
        } else {
            if (firstItemIsDate(dateFields)) {
                return TYPE_DATE_TIME;
            } else {
                return TYPE_TIME_DATE;
            }
        }
    }

    /**
     * Converts an input date, which may be in word or short form, to the
     * program-wide standard of "dd/MM/yyyy".
     */
    private static String formatDate(String str) {
        String result = str;
        if (isValidWordDate(str)) {
            switch (str.toLowerCase()) {
                case ALT_DATE_TODAY:
                    result = getCurrDateStr();
                    break;

                case ALT_DATE_TOMORROW:
                case ALT_DATE_TMR:
                    result = getTmrDateStr();
                    break;
            }
        } else if (isValidNumericalDate(str)) {
            if (isMissingYear(str)) {
                result = result + "/" + getCurrYearStr();
            }
            String[] dateFieldsStr = new String[3];
            int[] dateFieldsInt = splitDateToIntArray(result);
            dateFieldsStr[0] = toDoubleDigitStr(dateFieldsInt[0]);
            dateFieldsStr[1] = toDoubleDigitStr(dateFieldsInt[1]);
            dateFieldsStr[2] = toFourDigitStr(dateFieldsInt[2]);
            result = dateFieldsStr[0] + "/" + dateFieldsStr[1] + "/" +
                     dateFieldsStr[2];
        }

        return result;
    }

    /**
     * Converts an input time, if it is "now", to 24Hr time. Returns the input
     * itself otherwise.
     */
    private static String formatTime(String str) {
        String result = str;
        if (isValidWordTime(str)) {
            result = getCurrTimeStr();
        }
        return result;
    }

    /**
     * Returns true if the input str is of the format d/M, where d can be
     * extended to dd and M can be MM.
     */
    private static boolean isMissingYear(String str) {
        String[] dateFields = str.split("/");
        assert (dateFields.length == LENGTH_DATE_SHORT || dateFields.length == LENGTH_DATE_LONG);
        return dateFields.length == LENGTH_DATE_SHORT;
    }

    /** Splits a date from the format of dd/MM/yyyy to an int array of size 3. */
    private static int[] splitDateToIntArray(String str) {
        assert (isValidNumericalDate(str));
        assert (!isMissingYear(str));
        String[] strArr = splitDateToStrArray(str);
        int[] intArr = new int[] { Integer.parseInt(strArr[0]),
                                  Integer.parseInt(strArr[1]),
                                  Integer.parseInt(strArr[2]) };
        return intArr;
    }

    /**
     * Splits a date from the format of "dd/MM/yyyy" to a String array {dd, MM,
     * yyyy}.
     */
    private static String[] splitDateToStrArray(String str) {
        return str.split("/");
    }

    /** Checks if the input array contains only 1 item. */
    private static <E> boolean isSingleItemArray(E[] array) {
        return array.length == 1;
    }

    /**
     * Checks if the first item of the array is a valid date.
     */
    private static boolean firstItemIsDate(String[] dateFields) {
        assert (dateFields.length > 0) : "Empty array input for firstItemIsDate()";
        return isValidDate(dateFields[0]);
    }

    /** See {@link Parser#isValidTime(String)}. */
    static boolean isValidTime(String timeStr) {
        return isValidWordTime(timeStr) || isValidNumericalTime(timeStr);
    }

    /**
     * Checks if the input <code>timeStr</code> is a valid word-based time. This
     * method currently only accepts "now" as a valid word-based time.
     */
    private static boolean isValidWordTime(String timeStr) {
        return timeStr.equalsIgnoreCase(ALT_TIME_NOW);
    }

    /**
     * Checks if the input <code>timeStr</code> is a valid numerical time. This
     * method assumes the 24HR time format, i.e. 0000-2359.
     */
    private static boolean isValidNumericalTime(String timeStr) {
        try {
            String hoursStr = timeStr.substring(0, 2);
            String minStr = timeStr.substring(2, 4);

            int hoursInt = Integer.parseInt(hoursStr);
            int minInt = Integer.parseInt(minStr);

            boolean isValidHH = (hoursStr.equals("00") || hoursInt > 0) &&
                                hoursInt < 24;
            boolean isValidMM = (minStr.equals("00") || minInt > 0) &&
                                minInt < 60;

            return isValidHH && isValidMM;
        } catch (IndexOutOfBoundsException e) {
            return false;
        } catch (NumberFormatException e) {
            return false;
        }
    }

    /** See {@link Parser#isValidDate(String)}. */
    static boolean isValidDate(String str) {
        return isValidWordDate(str) || isValidNumericalDate(str);
    }

    /**
     * Checks if <code>str</code> is one of the words that are accepted as
     * substitutes for dates.
     */
    private static boolean isValidWordDate(String str) {
        return Arrays.asList(LIST_DATE_WORDS).contains(str.toLowerCase());
    }

    /**
     * Checks if the input <code>str</code> is a valid numerical date. The
     * allowed formats include day/month, as well as day/month/year formats,
     * where leading zeroes can be ignored and year can be truncated.
     */
    private static boolean isValidNumericalDate(String str) {
        boolean result;

        try {
            String[] components = str.split("/");
            String day = components[0];
            String month = components[1];
            String year; // Needed to calculate leap years

            boolean hasValidCompLengths = false;
            boolean hasValidIntComp = false;

            if (components.length == 2) {
                year = getCurrYearStr();
                hasValidCompLengths = lengthIsBetweenInc(1, 2, day) &&
                                      lengthIsBetweenInc(1, 2, month);
                hasValidIntComp = isValidMonth(month) &&
                                  isValidDay(day, month, year);
            } else if (components.length == 3) {
                year = components[2];
                hasValidCompLengths = lengthIsBetweenInc(1, 2, day) &&
                                      lengthIsBetweenInc(1, 2, month) &&
                                      lengthIsBetweenInc(2, 4, year) &&
                                      year.length() != 3;
                hasValidIntComp = isValidYear(year) && isValidMonth(month) &&
                                  isValidDay(day, month, year);
            }

            result = hasValidCompLengths && hasValidIntComp;
        } catch (Exception e) {
            result = false;
        }

        return result;
    }

    /**
     * Checks if the length of <code>str</code> is between
     * <code>rangeStartInc</code> and <code>rangeEndInc</code>, inclusive.
     */
    private static boolean lengthIsBetweenInc(int rangeStartInc,
                                              int rangeEndInc, String str) {
        return str.length() >= rangeStartInc && str.length() <= rangeEndInc;
    }

    /**
     * Checks if the input date values can form a valid day.
     * <p>
     * Converts input <code>String</code> values to <code>int</code> values and
     * calls the overloaded method {@link #isValidDay(int, int, int)}.
     */
    private static boolean isValidDay(String day, String month, String year) {
        try {
            int dayNum = Integer.parseInt(day);
            int monthNum = Integer.parseInt(month);
            int yearNum = Integer.parseInt(year);
            return isValidDay(dayNum, monthNum, yearNum);
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * Checks if the input <code>day</code> is valid, by checking if it falls
     * within the <code>month</code>'s number of days.
     * <p>
     * The input <code>year</code> is required to determine the number of days
     * in February (leap years).
     * 
     * @return <code>true</code> if the day is valid, <br>
     *         <code>false</code> otherwise.
     */
    private static boolean isValidDay(int day, int month, int year) {
        assert isValidYear(Integer.toString(year));

        boolean isLeapYear = isLeapYear(year);

        switch (month) {
            case 1:
            case 3:
            case 5:
            case 7:
            case 8:
            case 10:
            case 12:
                return day > 0 && day <= 31;

            case 2:
                if (isLeapYear) {
                    return day > 0 && day <= 29;
                } else {
                    return day > 0 && day <= 28;
                }

            case 4:
            case 6:
            case 9:
            case 11:
                return day > 0 && day <= 30;
        }
        return false;
    }

    /**
     * Checks if the input <code>year</code> is a leap year. <br>
     * A leap year is a year that is divisible by 400, or divisible by 4 but not
     * by 100.
     * <p>
     * <i> Note: This formula started proper from 8 AD, and does not apply to
     * BC. </i>
     */
    private static boolean isLeapYear(int year) {
        assert (year >= 8) : "Invalid year! Our formula only works for after 8 AD";
        return (year % 400 == 0) || (year % 4 == 0 && year % 100 != 0);
    }

    /**
     * Checks if the input <code>String</code> can be parsed to a valid month.
     * 
     * <p>
     * <i> The input should be an integer String, and a valid month is between 1
     * and 12 inclusive. </i>
     * 
     * @param monthStr
     *            A <code>String</code> containing only an integer.
     */
    private static boolean isValidMonth(String monthStr) {
        try {
            int monthNum = Integer.parseInt(monthStr);
            return isValidMonth(monthNum);
        } catch (Exception e) {
            return false;
        }
    }

    /** Checks if the input <code>int</code> is a valid calendar month number. */
    private static boolean isValidMonth(int month) {
        return month > 0 && month <= 12;
    }

    /**
     * Checks if the input <code>String</code> is a valid year.
     * 
     * <p>
     * <i> The input should be an integer String, and a valid month is taken to
     * be after 1819 (arbitrary value). </i>
     * 
     * @param yearStr
     *            A <code>String</code> containing only an integer.
     */
    private static boolean isValidYear(String yearStr) {
        try {
            int yearNum = Integer.parseInt(yearStr);
            if (yearStr.length() == 4) {
                return yearNum >= YEAR_MINIMUM;
            } else if (yearStr.length() == 2) {
                return (yearNum >= 0 && yearNum < 100);
            } else {
                return false;
            }
        } catch (Exception e) {
            return false;
        }
    }

    /** Returns true if <code>str</code> contains a valid date. */
    static boolean containsDate(String str) {
        String[] strFields = str.split(" ");

        for (int i = 0; i < strFields.length; i++) {
            if (isValidDate(strFields[i])) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns the first valid date String found in <code>str</code>. Should
     * only be called if <code>str</code> {@link #containsDate(String) contains
     * a Date}.
     */
    static String getFirstDate(String str) {
        assert containsDate(str) : "this method should be called only after checking if there's a date";
        String[] strFields = str.split(" ");

        for (int i = 0; i < strFields.length; i++) {
            if (isValidDate(strFields[i])) {
                return formatDate(strFields[i]);
            }
        }

        return null;
    }

    /** Returns true if <code>str</code> contains a valid time. */
    static boolean containsTime(String str) {
        String[] strFields = str.split(" ");

        for (int i = 0; i < strFields.length; i++) {
            if (isValidTime(strFields[i])) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns the first valid time String found in <code>str</code>. Should
     * only be called if <code>str</code> {@link #containsTime(String) contains
     * a Time}.
     */
    static String getFirstTime(String str) {
        assert containsTime(str) : "this method should be called only after checking if there's a time";
        String[] strFields = str.split(" ");

        for (int i = 0; i < strFields.length; i++) {
            if (isValidTime(strFields[i])) {
                return formatTime(strFields[i]);
            }
        }

        return null;
    }

    // FOR TESTING PURPOSES (Exploratory)
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.println("Input as a DateTime:");
        String input = "";
        while (!input.equals("exit")) {
            input = sc.nextLine();
            try {
                if (!input.equals("exit")) {
                    System.out.println(parseToDateTime(input));
                } else {
                    System.out.println("End of test.");
                }
            } catch (Exception e) {
                System.out.println("Error: " + e.getMessage());
            }
        }

        sc.close();
    }

}

	// End of segment: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\parser\DateParser.java





	/**
	 * origin: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\parser\FileParser.java
	 */

package parser;

import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

import objects.DateTime;
import objects.Task;
import objects.TaskType;

/**
 * The FileParser handles parsing Strings that have been stored by Storage,
 * which it uses to create Tasks. It relies on the DateParser for date-related
 * methods.
 */
public class FileParser {

    /** Used to initialise string values to empty string */
    private static final String STR_INIT = "";
    // Accepted inputs for Task Type
    private static final String TYPE_BLOCK = "block";
    private static final String TYPE_DONE = "done";
    private static final String TYPE_TODO = "todo";

    // Required keywords for parsing from file
    private static final String KEYWORD_BREAKPOINT = "###";
    private static final String KEYWORD_START = "start:";
    private static final String KEYWORD_DUE = "due:";
    private static final String KEYWORD_COMPLETED = "completed:";
    private static final String KEYWORD_TYPE = "type:";

    /** Stores the list of accepted keywords, excluding KEYWORD_BREAKPOINT */
    private static final String[] LIST_KEYWORDS = { KEYWORD_START, KEYWORD_DUE,
                                                   KEYWORD_COMPLETED,
                                                   KEYWORD_TYPE };

    // Indices for storing Task parameters in an String array
    private static final int INDEX_NAME = 0;
    private static final int INDEX_START = 1;
    private static final int INDEX_DUE = 2;
    private static final int INDEX_COMPLETED = 3;
    private static final int INDEX_TASKTYPE = 4;

    /** Stores the indices of Date-Time parameters for reference */
    private static final int[] LIST_DATE_INDICES = { INDEX_START, INDEX_DUE,
                                                    INDEX_COMPLETED };

    // Indices used to retrieve DateTime parameters after extraction from String
    // array
    private static final int INDEX_START_DT = 0;
    private static final int INDEX_DUE_DT = 1;
    private static final int INDEX_COMPLETED_DT = 2;

    /**
     * See {@link Parser#parseToTask(String)}.
     */
    static Task parse(String text) {
        String[] textItems = removeEmptyStrings(text.split(" "));

        // Params correspond to: name, start, due, completed, type
        String[] params = newArrOfEmptyStr(5);
        List<String> tags = new ArrayList<String>();

        // Sort out data
        collectParams(textItems, params, tags);
        DateTime[] dateTimes = convertToDateTimes(params);

        // Assign parameter inputs for Task constructor
        String name = params[INDEX_NAME];
        DateTime start = dateTimes[INDEX_START_DT];
        DateTime due = dateTimes[INDEX_DUE_DT];
        DateTime completed = dateTimes[INDEX_COMPLETED_DT];
        TaskType type = getTaskType(params);

        Task newTask = new Task(name, start, due, completed, tags, type);
        return newTask;
    }

    /**
     * Returns a String array of size <code>size</code> filled with empty
     * Strings ("").
     */
    private static String[] newArrOfEmptyStr(int size) {
        String[] arr = new String[size];
        for (int i = 0; i < size; i++) {
            arr[i] = STR_INIT;
        }
        return arr;
    }

    /**
     * Returns a clone of the input String array, excluding empty Strings. This
     * gets rid of repeated spaces in a user's input.
     * 
     * @return String array excluding empty strings. Minimum size is 0.
     * 
     */
    private static String[] removeEmptyStrings(String[] arr) {
        ArrayList<String> list = new ArrayList<String>();
        for (int i = 0; i < arr.length; i++) {
            if (!arr[i].isEmpty()) {
                list.add(arr[i]);
            }
        }

        String[] result = new String[list.size()];
        for (int i = 0; i < list.size(); i++) {
            result[i] = list.get(i);
        }

        return result;
    }

    /**
     * Parses through textItems and sorts words into params and tags. Valid tags
     * are added to tags, and valid parameters are placed into their respective
     * positions in params.
     */
    private static void collectParams(String[] textItems, String[] params,
                                      List<String> tags) {
        int fieldIndex = 0;
        boolean breakPointMet = false;

        for (int i = 0; i < textItems.length; i++) {
            String currWord = textItems[i];
            if (!breakPointMet && currWord.equals(KEYWORD_BREAKPOINT)) {
                breakPointMet = true;
            } else if (breakPointMet && isValidKeyword(currWord)) {
                fieldIndex++;
                assert (fieldIndex < 5) : "Too many parameters for TaskParser!";
            } else if (breakPointMet && hasValidHashTag(currWord)) {
                tags.add(currWord);
            } else {
                params[fieldIndex] = params[fieldIndex].concat(" " + currWord)
                        .trim();
            }
        }

        assert (fieldIndex == 4) : "TaskParser is missing parameter names.";
    }

    private static boolean isValidKeyword(String word) {
        return Arrays.asList(LIST_KEYWORDS).contains(word.toLowerCase());
    }

    private static boolean hasValidHashTag(String word) {
        return word.startsWith("#") && (word.length() > 1);
    }

    /**
     * This method converts the String fields in <code>params</code> that are
     * supposed to be DateTimes in Task. Uses LIST_DATES_INDEX for reference.
     * 
     * @return A DateTime array containing the converted parameters.
     */
    private static DateTime[] convertToDateTimes(String[] params) {
        List<DateTime> converted = new ArrayList<DateTime>();

        for (int i = 0; i < params.length; i++) {
            if (isMemberOf(LIST_DATE_INDICES, i)) {
                String currDtStr = params[i];
                if (currDtStr.isEmpty()) {
                    converted.add(new DateTime());
                } else {
                    assert (DateParser.isValidDateTime(currDtStr)) : "Invalid DateTime saved!";
                    converted.add(DateParser.parseToDateTime(currDtStr));
                }
            }
        }

        assert converted.size() == LIST_DATE_INDICES.length : "Wrong number of DateTimes converted!";
        DateTime[] dateTimes = converted.toArray(new DateTime[0]);
        return dateTimes;
    }

    /** Checks if <code>toCheck</code> is a member of <code>arr</code>. */
    private static boolean isMemberOf(int[] arr, int toCheck) {
        for (int index = 0; index < arr.length; index++) {
            if (toCheck == arr[index]) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns the TaskType of a Task using the parameters collected. The
     * TaskType is read using the index <code>INDEX_TASKTYPE</code>.
     */
    private static TaskType getTaskType(String[] params) {
        TaskType type = TaskType.TODO;
        switch (params[INDEX_TASKTYPE].toLowerCase()) {
            case TYPE_TODO:
                break;

            case TYPE_DONE:
                type = TaskType.DONE;
                break;

            case TYPE_BLOCK:
                type = TaskType.BLOCK;
                break;

            default:
                assert false : "Invalid TaskType while parsing from file!";
        }
        return type;
    }

    // FOR EXPLORATORY TESTING PURPOSES
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Type as per file input:");

        String input = STR_INIT;
        while (!input.equals("exit")) {
            input = sc.nextLine();
            try {
                System.out.println(parse(input));
            } catch (AssertionError e) {
                System.out.println(e.getMessage());
            }
        }

        sc.close();
    }

}

	// End of segment: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\parser\FileParser.java





	/**
	 * origin: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\parser\InputParser.java
	 */

package parser;

import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

import objects.DateTime;
import objects.TaskParam;
import logic.Command;
import logic.CommandAdd;
import logic.CommandBlock;
import logic.CommandDelete;
import logic.CommandDisplay;
import logic.CommandDone;
import logic.CommandEdit;
import logic.CommandOthers;
import logic.CommandRestore;
import logic.CommandSearch;
import logic.CommandTodo;

/**
 * The InputParser handles the parsing of Strings input by the user. It is
 * mostly self-contained, but relies on DateParser for date-related methods.
 */
public class InputParser {

    // All possible Command types (in string)
    private static final String TYPE_HELP = "help";
    private static final String TYPE_GOTTA = "gotta";
    private static final String TYPE_ADD = "add";
    private static final String TYPE_EDIT = "edit";
    private static final String TYPE_DELETE = "delete";
    private static final String TYPE_RESTORE = "restore";
    private static final String TYPE_SEARCH = "search";
    private static final String TYPE_DISPLAY = "display";
    private static final String TYPE_SHOW = "show";
    private static final String TYPE_BLOCK = "block";
    private static final String TYPE_DONE = "done";
    private static final String TYPE_TODO = "todo";
    private static final String TYPE_UNDO = "undo";
    private static final String TYPE_REDO = "redo";
    private static final String TYPE_EXIT = "exit";
    private static final String TYPE_RESET = "reset";

    private static final String[] STR_ARRAY_EMPTY = new String[0];

    private static final String[] PARAMS_EDIT = { "due", "start", "tags" };
    private static final String[] PARAMS_BLOCK = { "from", "to" };
    private static final String[] PARAMS_DATE = { "due", "start" };
    private static final String[] PARAMS_DATE_FULL = { "due", "by", "start",
                                                      "from", "end", "to" };
    private static final String[] PARAMS_DISPLAY = { "search", "all", "done",
                                                    "deleted", "block",
                                                    "today", "tomorrow",
                                                    "upcoming", "someday" };
    private static final String[] PARAMS_DELETE = { "all", "search", "done" };
    private static final String[] PARAMS_STATUS = { "done", "deleted", "all" };

    // ========== MAIN PARSE METHOD ==========//

    /**
     * Parses the input String into a Command of the relevant type. The Command
     * will store relevant information contained in the String.
     * 
     * @return Command object of the relevant subclass
     * @throws IllegalArgumentException
     *             when a user input is invalid. The exception will contain a
     *             message related to the error.
     */
    static Command parse(String input) throws IllegalArgumentException {
        // Note: The parser is built to analyse input on a word-by-word basis.
        assert (input != null);

        // Split by spaces (break into "words"), ignoring empty Strings that
        // result from repeated spaces
        String[] commandItems = removeEmptyStrings(input.split(" "));

        if (commandItems.length > 0) {
            String commandType = getCommandWord(commandItems);
            String[] commandParams = removeFirstWord(commandItems);

            switch (commandType) {
                case TYPE_ADD:
                case TYPE_GOTTA:
                    return parseAdd(commandParams);

                case TYPE_EDIT:
                    return parseEdit(commandParams);

                case TYPE_DELETE:
                    return parseDelete(commandParams);

                case TYPE_RESTORE:
                    return parseRestore(commandParams);

                case TYPE_SEARCH:
                    return parseSearch(commandParams);

                case TYPE_DISPLAY:
                case TYPE_SHOW:
                    return parseDisplay(commandParams);

                case TYPE_BLOCK:
                    return parseBlock(commandParams);

                case TYPE_DONE:
                    return parseDone(commandParams);

                case TYPE_TODO:
                    return parseTodo(commandParams);

                case TYPE_UNDO:
                case TYPE_REDO:
                case TYPE_RESET:
                case TYPE_HELP:
                case TYPE_EXIT:
                    return new CommandOthers(commandType);
            }
        }
        throw new IllegalArgumentException("Invalid command!");
    }

    /**
     * Returns the command word from a given string array. The command word is
     * assumed to be the first item of the array, and is returned in lower-case.
     * 
     * @param commandItems
     *            An array containing a command input split by spaces
     * @return String containing command word in lower-case
     */
    private static String getCommandWord(String[] commandItems) {
        return commandItems[0].toLowerCase();
    }

    /**
     * Returns a clone of the input String array, excluding the first word. This
     * is used to remove the command word, which is assumed to be the first item
     * of the array.
     * 
     * @return An array smaller than the input array by 1. Minimum size is 0.
     */
    private static String[] removeFirstWord(String[] commandItems) {
        try {
            String[] commandParams = new String[commandItems.length - 1];
            for (int i = 1; i < commandItems.length; i++) {
                commandParams[i - 1] = commandItems[i];
            }
            return commandParams;
        } catch (Exception e) {
            return STR_ARRAY_EMPTY;
        }
    }

    /**
     * Returns a clone of the input String array, excluding empty Strings. This
     * gets rid of repeated spaces in a user's input.
     * 
     * @return String array excluding empty strings. Minimum size is 0.
     * 
     */
    private static String[] removeEmptyStrings(String[] arr) {
        ArrayList<String> list = new ArrayList<String>();
        for (int i = 0; i < arr.length; i++) {
            if (!arr[i].isEmpty()) {
                list.add(arr[i]);
            }
        }

        String[] result = new String[list.size()];
        for (int i = 0; i < list.size(); i++) {
            result[i] = list.get(i);
        }

        return result;
    }

    // ========== INDIVIDUAL PARSE-COMMAND FUNCTIONS ==========//

    private static Command parseTodo(String[] commandParams) {
        List<TaskParam> todoFields = new ArrayList<TaskParam>();

        try {
            String param = commandParams[0];
            if (param.equalsIgnoreCase("last")) {
                addTaskParamToFields(todoFields, "rangeType", "last");
            } else if (isInteger(param)) {
                addTaskParamToFields(todoFields, "rangeType", "id");
                addTaskParamToFields(todoFields, "id", param);
            } else {
                throw new IllegalArgumentException("Invalid argument for todo!");
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            throw new IllegalArgumentException("Missing arguments for todo!");
        }

        return new CommandTodo(todoFields);
    }

    private static Command parseDone(String[] commandParams) {
        List<TaskParam> doneFields = new ArrayList<TaskParam>();

        try {
            String firstWord = commandParams[0];
            if (DateParser.isValidDate(firstWord)) {
                addTaskParamToFields(doneFields, "rangeType", "date");
                addTaskParamToFields(doneFields, "date", firstWord);
            } else if (firstWord.equalsIgnoreCase("all")) {
                addTaskParamToFields(doneFields, "rangeType", "all");
            } else if (isInteger(firstWord)) {
                addTaskParamToFields(doneFields, "rangeType", "id");
                addTaskParamToFields(doneFields, "id", firstWord);
            } else {
                throw new IllegalArgumentException("Invalid argument for done!");
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            throw new IllegalArgumentException("No arguments for done");
        }

        return new CommandDone(doneFields);
    }

    private static Command parseBlock(String[] commandParams) {
        if (commandParams.length == 0) {
            throw new IllegalArgumentException(
                    "You can't block nothing! Input a date or time frame!");
        }

        String currFieldOrig = "";
        String currField = "";
        List<TaskParam> blockFields = new ArrayList<TaskParam>();
        ArrayList<String> availParams = generateParamArrayList(PARAMS_BLOCK);

        String currWord;
        boolean currHasDate = false;
        boolean currHasTime = false;

        for (int j = 0; j < commandParams.length; j++) {
            currWord = commandParams[j];
            if (hasValidHashTag(currWord)) {
                // No matter the current field, collect hashtags first
                blockFields.add(new TaskParam("tag", currWord));
            } else if (currField.equalsIgnoreCase(currWord) &&
                       !currWord.isEmpty() && !currHasDate && !currHasTime) {
                // If parameters are repeated, add the previous one to name
                addToFieldParam(blockFields, "name", currFieldOrig);
            } else if (availParams.contains(currWord.toLowerCase())) {
                // If the current word is an available parameter name
                if (isParamOf(PARAMS_BLOCK, currField) && !currHasDate &&
                    !currHasTime) {
                    // If the last parameter was not filled, it was not a
                    // parameter
                    addToFieldParam(blockFields, "name", currFieldOrig);
                    availParams.add(currField);
                }
                // Reassign currField values
                currField = currWord.toLowerCase();
                // Save the original word (with capitalisation)
                currFieldOrig = currWord;
                // Remove availability
                availParams.remove(currField);
                // Reset hasDate/Time values
                currHasDate = false;
                currHasTime = false;
            } else if (isParamOf(PARAMS_BLOCK, currField) &&
                       !currWord.isEmpty()) {
                // If currently a date parameter and string is not ""
                if (!currHasDate && DateParser.isValidDate(currWord)) {
                    addToFieldParam(blockFields, currField, currWord);
                    currHasDate = true;
                } else if (!currHasTime && DateParser.isValidTime(currWord)) {
                    addToFieldParam(blockFields, currField, currWord);
                    currHasTime = true;
                } else {
                    // If not a valid date/time, reset fields
                    // Add the parameter name to "name" if no date/time
                    // was assigned.
                    TaskParam nameParam = getTaskParam(blockFields, "name");
                    if (!currHasDate && !currHasTime) {
                        nameParam.addToField(currFieldOrig);
                        availParams.add(currField);
                    }
                    nameParam.addToField(currWord);
                    currField = "";
                    currFieldOrig = "";
                }
            } else {
                addToFieldParam(blockFields, "name", currWord);
            }
        }

        // catches if the last word was a parameter
        if (isParamOf(PARAMS_BLOCK, currField) && !currHasDate && !currHasTime) {
            addToFieldParam(blockFields, "name", currFieldOrig);
        }

        // Fill in empty dates
        TaskParam fromTp = getTaskParam(blockFields, "from");
        TaskParam toTp = getTaskParam(blockFields, "to");
        String fromStr = fromTp.getField();
        String toStr = toTp.getField();
        if (!DateParser.containsDate(fromStr) &&
            !DateParser.containsDate(toStr)) {
            String currDate = DateParser.getCurrDateStr();
            fromTp.addToField(currDate);
            toTp.addToField(currDate);
        } else if (!DateParser.containsDate(fromStr)) {
            String toDate = DateParser.getFirstDate(toStr);
            fromTp.addToField(toDate);
        } else if (!DateParser.containsDate(toStr)) {
            String fromDate = DateParser.getFirstDate(fromStr);
            toTp.addToField(fromDate);
        }

        // Check order of date/times; switch if necessary.
        // While checking, add the times as necessary
        fromStr = fromTp.getField();
        toStr = toTp.getField();
        DateTime fromDt = DateParser.parseToDateTime(fromStr);
        DateTime toDt = DateParser.parseToDateTime(toStr);
        if (fromDt.isLaterThan(toDt)) {
            if (fromDt.getDate().equals(toDt.getDate()) && (!DateParser
                    .containsTime(fromStr) || !DateParser.containsTime(toStr))) {
                // If the date is equal and at least one time is missing
                // Do nothing.
            } else {
                fromTp.setField(toStr);
                toTp.setField(fromStr);
            }

        }

        // Fill in empty times
        fromStr = fromTp.getField();
        toStr = toTp.getField();
        if (!DateParser.containsTime(fromStr)) {
            fromTp.addToField("0000");
        }
        if (!DateParser.containsTime(toStr)) {
            toTp.addToField("2359");
        }

        removeDuplicates(blockFields);

        return new CommandBlock(blockFields);

    }

    private static Command parseDisplay(String[] commandParams) {
        List<TaskParam> displayFields = new ArrayList<TaskParam>();

        if (commandParams.length == 0) {
            addTaskParamToFields(displayFields, "rangeType", "all");
        } else {
            String firstWord = commandParams[0];
            if (isParamOf(PARAMS_DISPLAY, firstWord)) {
                addTaskParamToFields(displayFields, "rangeType",
                                     firstWord.toLowerCase());
            } else if (isInteger(firstWord)) {
                addTaskParamToFields(displayFields, "rangeType", "id");
                addTaskParamToFields(displayFields, "id", firstWord);
            } else {
                throw new IllegalArgumentException(
                        "Invalid argument for display");
            }
        }

        return new CommandDisplay(displayFields);
    }

    private static Command parseDelete(String[] commandParams) {
        List<TaskParam> deleteFields = new ArrayList<TaskParam>();

        try {
            String firstWord = commandParams[0];
            if (DateParser.isValidDate(firstWord)) {
                addTaskParamToFields(deleteFields, "rangeType", "dates");
                addTaskParamToFields(deleteFields, "start", firstWord);
                addTaskParamToFields(deleteFields, "due", firstWord);
            } else if (isParamOf(PARAMS_DELETE, firstWord)) {
                addTaskParamToFields(deleteFields, "rangeType",
                                     firstWord.toLowerCase());
            } else if (isInteger(firstWord)) {
                addTaskParamToFields(deleteFields, "rangeType", "id");
                addTaskParamToFields(deleteFields, "id", firstWord);
            } else {
                throw new IllegalArgumentException(
                        "Invalid argument for delete");
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            throw new IllegalArgumentException("No arguments for delete");
        }

        return new CommandDelete(deleteFields);
    }

    private static Command parseRestore(String[] commandParams) {
        List<TaskParam> restoreFields = new ArrayList<TaskParam>();

        for (int i = 0; i < commandParams.length; i++) {
            String word = commandParams[i];
            if (!word.isEmpty()) {
                if (isInteger(word)) {
                    restoreFields.add(new TaskParam("rangeType", "id"));
                    restoreFields.add(new TaskParam("id", word));
                    return new CommandRestore(restoreFields);
                } else {
                    throw new IllegalArgumentException(
                            "Invalid argument for restore");
                }
            }
        }

        throw new IllegalArgumentException("No arguments for restore");

    }

    private static Command parseSearch(String[] commandParams) {
        List<TaskParam> searchFields = new ArrayList<TaskParam>();

        try {
            // Get index of the first word
            int firstWordIndex = 0;
            String firstWord = commandParams[0];
            while (firstWord.isEmpty() && firstWordIndex < commandParams.length) {
                firstWordIndex++;
                firstWord = commandParams[firstWordIndex];
            }

            // Check if the first word is a valid status parameter
            int startIndex = firstWordIndex;
            if (isParamOf(PARAMS_STATUS, firstWord)) {
                addTaskParamToFields(searchFields, "status",
                                     firstWord.toLowerCase());
                startIndex = firstWordIndex + 1;
            }

            // Categorise the rest of the string
            boolean dateIndicated = false;
            for (int i = startIndex; i < commandParams.length; i++) {
                String currWord = commandParams[i];
                if (DateParser.isValidDate(currWord)) {
                    if (!dateIndicated) {
                        searchFields.add(new TaskParam("date", currWord));
                        dateIndicated = true;
                    } else {
                        throw new IllegalArgumentException(
                                "You can only allowed to search one date at a time!");
                    }
                } else if (hasValidHashTag(currWord)) {
                    searchFields.add(new TaskParam("tag", currWord));
                } else if (!currWord.isEmpty()) {
                    searchFields.add(new TaskParam("word", currWord));
                }
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            throw new IllegalArgumentException("No arguments for search");
        }

        return new CommandSearch(searchFields);
    }

    private static Command parseEdit(String[] commandParams) {
        String currField = "";
        String currFieldOrig = "";
        String id;
        List<TaskParam> editFields = new ArrayList<TaskParam>();

        // TODO: Refactor to saveEditIdToField(); throw exceptions
        int firstWord = 0;
        try {
            id = commandParams[firstWord];
            while (id.isEmpty()) {
                firstWord++;
                id = commandParams[firstWord];
            }
            Integer.parseInt(id);
            editFields.add(new TaskParam("id", id));
        } catch (IndexOutOfBoundsException e) {
            throw new IllegalArgumentException("No task specified for edit!");
        } catch (NumberFormatException f) {
            throw new IllegalArgumentException("Invalid task ID for edit!");
        }

        ArrayList<String> availDateParams = generateParamArrayList(PARAMS_DATE);
        ArrayList<String> availDeleteParams = generateParamArrayList(PARAMS_EDIT);

        String currWord;
        boolean currHasDate = false;
        boolean currHasTime = false;
        boolean currHasDelete = false;

        // TODO: Refactor
        for (int j = 1; j < commandParams.length; j++) {
            currWord = commandParams[j];
            if (hasValidHashTag(currWord)) {
                // No matter the current field, collect hashtags first
                editFields.add(new TaskParam("tag", currWord));
            } else if ((currField.equals(getDateParamEquiv(currWord)) || currField
                    .equalsIgnoreCase(currWord)) &&
                       !currWord.isEmpty() &&
                       !currHasDate && !currHasTime) {
                // If parameters are repeated, add the previous one to name
                addToFieldParam(editFields, "name", currFieldOrig);
            } else if (currField.equals("delete") && !currWord.isEmpty()) {
                // If the last parameter was a delete
                if (availDeleteParams.contains(getDateParamEquiv(currWord))) {
                    // If delete has not been filled and the currWord is valid
                    addTaskParamToFields(editFields, "delete",
                                         getDateParamEquiv(currWord));
                    currHasDelete = true;
                    availDeleteParams.remove(getDateParamEquiv(currWord));
                } else {
                    // Else assume delete was not intended as a param
                    addToFieldParam(editFields, "name", currFieldOrig);
                    addToFieldParam(editFields, "name", currWord);
                }
                // Delete resets after the first non-tag input
                currField = "";
                currFieldOrig = "";
            } else if (availDateParams.contains(getDateParamEquiv(currWord)) ||
                       currWord.equalsIgnoreCase("delete")) {
                // If the current word is an available parameter name
                if (isParamOf(PARAMS_DATE_FULL, currField) && !currHasDate &&
                    !currHasTime) {
                    // If the last parameter was not filled, it was not a
                    // parameter
                    addToFieldParam(editFields, "name", currFieldOrig);
                    availDateParams.add(currField);
                }
                if (currField.equals("delete") && !currHasDelete) {
                    addToFieldParam(editFields, "name", currFieldOrig);
                }
                // Reassign currField values
                currField = getDateParamEquiv(currWord);
                // Save the original word (with capitalisation)
                currFieldOrig = currWord;
                // Remove availability
                if (isParamOf(PARAMS_DATE_FULL, currField)) {
                    availDateParams.remove(currField);
                }
                // Reset boolean values
                currHasDate = false;
                currHasTime = false;
                currHasDelete = false;
            } else if (isParamOf(PARAMS_DATE_FULL, currField) &&
                       !currWord.isEmpty()) {
                // If currently a date parameter and string is not ""
                if (!currHasDate && DateParser.isValidDate(currWord)) {
                    addToFieldParam(editFields, currField, currWord);
                    currHasDate = true;
                } else if (!currHasTime && DateParser.isValidTime(currWord)) {
                    addToFieldParam(editFields, currField, currWord);
                    currHasTime = true;
                } else {
                    // If not a valid date/time, reset fields
                    // Add the parameter name to "name" if no date/time
                    // was assigned.
                    TaskParam nameParam = getTaskParam(editFields, "name");
                    if (!currHasDate && !currHasTime) {
                        nameParam.addToField(currFieldOrig);
                        availDateParams.add(currField);
                    }
                    nameParam.addToField(currWord);
                    currField = "";
                    currFieldOrig = "";
                }
            } else {
                addToFieldParam(editFields, "name", currWord);
            }
        }

        // catches if the last word was a parameter
        if ((isParamOf(PARAMS_DATE_FULL, currField) && !currHasDate && !currHasTime) ||
            (currField.equals("delete") && !currHasDelete)) {
            addToFieldParam(editFields, "name", currFieldOrig);
        }

        // Check for input time with missing date
        TaskParam startTP = getTaskParam(editFields, "start");
        TaskParam dueTP = getTaskParam(editFields, "due");
        String startStr = startTP.getField();
        String dueStr = dueTP.getField();
        if (DateParser.containsTime(startStr) &&
            !DateParser.containsDate(startStr)) {
            if (DateParser.containsDate(dueStr)) {
                String dueDate = DateParser.getFirstDate(dueStr);
                startTP.addToField(dueDate);
            } else {
                String currDate = DateParser.getCurrDateStr();
                startTP.addToField(currDate);
                if (DateParser.containsTime(dueStr)) {
                    dueTP.addToField(currDate);
                }
            }
        } else if (DateParser.containsTime(dueStr) &&
                   !DateParser.containsDate(dueStr)) {
            if (DateParser.containsDate(startStr)) {
                String startDate = DateParser.getFirstDate(startStr);
                dueTP.addToField(startDate);
            } else {
                String currDate = DateParser.getCurrDateStr();
                dueTP.addToField(currDate);
                if (DateParser.containsTime(startStr)) {
                    dueTP.addToField(currDate);
                }
            }
        }

        removeDuplicates(editFields);
        checkStartDueOrder(editFields);

        return new CommandEdit(editFields);
    }

    private static Command parseAdd(String[] commandParams) {
        String currFieldOrig = "";
        String currField = "";
        List<TaskParam> addFields = new ArrayList<TaskParam>();
        ArrayList<String> availParams = generateParamArrayList(PARAMS_DATE);

        String currWord;
        boolean currHasDate = false;
        boolean currHasTime = false;

        for (int j = 0; j < commandParams.length; j++) {
            currWord = commandParams[j];
            if (hasValidHashTag(currWord)) {
                // No matter the current field, collect hashtags first
                addFields.add(new TaskParam("tag", currWord));
            } else if (currField.equals(getDateParamEquiv(currWord)) &&
                       !currWord.isEmpty() && !currHasDate && !currHasTime) {
                // If parameters are repeated, add the previous one to name
                addToFieldParam(addFields, "name", currFieldOrig);
            } else if (availParams.contains(getDateParamEquiv(currWord))) {
                // If the current word is an available parameter name
                if (isParamOf(PARAMS_DATE_FULL, currField) && !currHasDate &&
                    !currHasTime) {
                    // If the last parameter was not filled, it was not a
                    // parameter
                    addToFieldParam(addFields, "name", currFieldOrig);
                    availParams.add(currField);
                }
                // Reassign currField values
                currField = getDateParamEquiv(currWord);
                // Save the original word (with capitalisation)
                currFieldOrig = currWord;
                // Remove availability
                availParams.remove(currField);
                // Reset hasDate/Time values
                currHasDate = false;
                currHasTime = false;
            } else if (isParamOf(PARAMS_DATE_FULL, currField) &&
                       !currWord.isEmpty()) {
                // If currently a date parameter and string is not ""
                if (!currHasDate && DateParser.isValidDate(currWord)) {
                    addToFieldParam(addFields, currField, currWord);
                    currHasDate = true;
                } else if (!currHasTime && DateParser.isValidTime(currWord)) {
                    addToFieldParam(addFields, currField, currWord);
                    currHasTime = true;
                } else {
                    // If not a valid date/time, reset fields
                    // Add the parameter name to "name" if no date/time
                    // was assigned.
                    TaskParam nameParam = getTaskParam(addFields, "name");
                    if (!currHasDate && !currHasTime) {
                        nameParam.addToField(currFieldOrig);
                        availParams.add(currField);
                    }
                    nameParam.addToField(currWord);
                    currField = "";
                    currFieldOrig = "";
                }
            } else {
                addToFieldParam(addFields, "name", currWord);
            }
        }

        // catches if the last word was a parameter
        if (isParamOf(PARAMS_DATE_FULL, currField) && !currHasDate &&
            !currHasTime) {
            addToFieldParam(addFields, "name", currFieldOrig);
        }

        // Check for input time with missing date
        TaskParam startTP = getTaskParam(addFields, "start");
        TaskParam dueTP = getTaskParam(addFields, "due");
        String startStr = startTP.getField();
        String dueStr = dueTP.getField();
        if (DateParser.containsTime(startStr) &&
            !DateParser.containsDate(startStr)) {
            if (DateParser.containsDate(dueStr)) {
                String dueDate = DateParser.getFirstDate(dueStr);
                startTP.addToField(dueDate);
            } else {
                String currDate = DateParser.getCurrDateStr();
                startTP.addToField(currDate);
                if (DateParser.containsTime(dueStr)) {
                    dueTP.addToField(currDate);
                }
            }
        } else if (DateParser.containsTime(dueStr) &&
                   !DateParser.containsDate(dueStr)) {
            if (DateParser.containsDate(startStr)) {
                String startDate = DateParser.getFirstDate(startStr);
                dueTP.addToField(startDate);
            } else {
                String currDate = DateParser.getCurrDateStr();
                dueTP.addToField(currDate);
                if (DateParser.containsTime(startStr)) {
                    dueTP.addToField(currDate);
                }
            }
        }

        removeDuplicates(addFields);
        checkStartDueOrder(addFields);

        return new CommandAdd(addFields);
    }

    private static boolean hasValidHashTag(String word) {
        return word.startsWith("#") && (word.length() > 1);
    }

    /**
     * Checks if input <code>word</code> is a member of input
     * <code>paramList</code>. This is used within the parser to check whether a
     * given word is a valid parameter.
     * 
     * @param paramList
     *            A list of valid parameters (to check against).
     * @param word
     *            The word to check.
     * @return <b>true</b> if <code>word</code> is a member of
     *         <code>paramList</code>.
     */
    private static boolean isParamOf(String[] paramList, String word) {
        return Arrays.asList(paramList).contains(word.toLowerCase());
    }

    /**
     * Creates a new, mutable ArrayList of Strings containing the members of the
     * input String Array.
     */
    private static ArrayList<String> generateParamArrayList(String[] paramList) {
        ArrayList<String> list = new ArrayList<String>();

        for (String p : paramList) {
            list.add(p);
        }

        return list;
    }

    /**
     * Converts alternative accepted user input for date parameters into
     * system-accepted ones for consistency in the parser.
     * <p>
     * Alternatives for "due": "by", "to", "end". <br>
     * Alternative for "start": "from".
     * */
    private static String getDateParamEquiv(String word) {
        String wordLC = word.toLowerCase();
        switch (wordLC) {
            case "by":
            case "to":
            case "end":
                return "due";

            case "from":
                return "start";
        }

        return wordLC;
    }

    /**
     * Searches <code>fields</code> and returns the TaskParam whose
     * <code>name</code> is equal to the input <code>currField</code>. If there
     * is no such TaskParam, this method creates it, adds it to
     * <code>fields</code> and returns it.
     */
    private static TaskParam getTaskParam(List<TaskParam> fields,
                                          String currField) {
        // Attempt to get TaskParam named currField from List
        for (TaskParam tp : fields) {
            if (tp.getName().equals(currField)) {
                return tp;
            }
        }

        // If not found, create it
        TaskParam newParam = new TaskParam(currField, "");
        fields.add(newParam);
        return newParam;

    }

    /**
     * @param fields
     */
    private static void checkStartDueOrder(List<TaskParam> fields) {
        TaskParam startTP = getTaskParam(fields, "start");
        TaskParam dueTP = getTaskParam(fields, "due");
        if (!startTP.getField().isEmpty() && !dueTP.getField().isEmpty()) {
            DateTime startDT = DateParser.parseToDateTime(startTP.getField());
            DateTime dueDT = DateParser.parseToDateTime(dueTP.getField());
            if (startDT.compareTo(dueDT) > 0) {
                fields.remove(startTP);
                fields.remove(dueTP);
                addTaskParamToFields(fields, "due", startTP.getField());
                addTaskParamToFields(fields, "start", dueTP.getField());
            }
        }
    }

    /**
     * Gets the TaskParam of the name <code>field</code> from the list
     * <code>fields</code>, and adds the input <code>content</code> to it.
     */
    private static void addToFieldParam(List<TaskParam> fields, String field,
                                        String content) {
        getTaskParam(fields, field).addToField(content);
    }

    /**
     * Adds a new TaskParam with the name <code>paramName</code> and content
     * <code>paramField</code> to the input <code>fields</code>.
     */
    private static boolean addTaskParamToFields(List<TaskParam> fields,
                                                String paramName,
                                                String paramField) {
        return fields.add(new TaskParam(paramName, paramField));
    }

    private static <E> void removeDuplicates(List<E> list) {
        List<E> toDelete = new ArrayList<E>();

        for (int i = 0; i < list.size(); i++) {
            for (int j = i + 1; j < list.size(); j++) {
                if (list.get(i).equals(list.get(j))) {
                    toDelete.add(list.get(j));
                    break;
                }
            }
        }

        for (E item : toDelete) {
            list.remove(item);
        }
    }

    private static boolean isInteger(String str) {
        try {
            Integer.parseInt(str);
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }

    // FOR TESTING PURPOSES (Exploratory)
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        System.out.println("Input as a user would:");
        String input = "";
        while (!input.equals("exit")) {
            input = sc.nextLine();
            System.out.println(parse(input));
        }

        sc.close();
    }

}

	// End of segment: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\parser\InputParser.java





	/**
	 * origin: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\parser\Parser.java
	 */

package parser;

import objects.DateTime;
import objects.Task;
import logic.Command;

/**
 * This class is the facade for all other parsing methods. These include parsing
 * from user input, parsing from file, as well as date-related methods. The
 * facade pattern is used to simplify interactions with the parser package.
 * <p>
 * The Parser classes (DateParser, etc.) have been kept as static classes
 * because they store no instance data at all. There is no benefit in making
 * them instance objects; in fact, doing so will complicate code unnecessarily.
 * 
 */
public class Parser {

    /**
     * Parses the input String into a Command of the relevant type. The Command
     * will store relevant information contained in the String.
     * 
     * @return Command object of the relevant subclass
     * @throws IllegalArgumentException
     *             when a user input is invalid. The exception will contain a
     *             message related to the error.
     */
    public static Command parse(String input) throws IllegalArgumentException {
        return InputParser.parse(input);
    }

    /**
     * Forms a <code>Task</code> object by parsing a <code>String</code>
     * containing the stored string literals.
     * <p>
     * Note that the input <code>String</code> must be of the given
     * format(below), contain all four parameters names ("start:" to "type:"),
     * and have spaces between tags and parameter names. The position of the
     * tags is flexible as long as it comes after "start:".
     * 
     * @param text
     *            format:
     *            {@literal "<name> ### start: <date/time> due: <date/time> completed: 
     * <date/time> <tags> type: <type>"}
     */
    public static Task parseToTask(String text) {
        return FileParser.parse(text);
    }

    /**
     * Checks and then parses the input <code>String</code> into a
     * <code>DateTime</code> object. The date/time must be in one of four
     * formats (below). An <code>IllegalArgumentException</code> will be thrown
     * if the input is not one of the following formats, or if the date/time
     * values are invalid (e.g. 40/01/2014 2401).
     * <ol>
     * Formats accepted:
     * <li>Date only: dd/MM/yyyy
     * <li>Time only: HHmm
     * <li>Date and Time: dd/MM/yyyy HHmm
     * <li>Time and Date: HHmm dd/MM/yyyy
     * </ol>
     * 
     * @return <code>DateTime</code> object containing date in
     *         <code>dd/MM/yyyy</code> and time in <code>HHmm</code>
     */
    // TODO: Add chain of @See for consistency between definition of valid
    // dates/times
    public static DateTime parseToDateTime(String str) {
        return DateParser.parseToDateTime(str);
    }

    /**
     * Returns the current date and time in a <code>DateTime</code> object.
     * <p>
     * <i>Uses the default system settings for date and time.</i>
     * 
     * @return <code>DateTime</code> object containing date in
     *         <code>dd/MM/yyyy</code> and time in <code>HHmm</code>
     */
    public static DateTime getCurrDateTime() {
        return DateParser.getCurrDateTime();
    }

    /**
     * Returns the current date and time in a <code>String</code>.
     * <p>
     * <i>Uses the default system settings for date and time.</i>
     * 
     * @return <code>String</code> object containing date in
     *         <code>dd/MM/yyyy</code> and time in <code>HHmm</code>
     */
    public static String getCurrDateTimeStr() {
        return DateParser.getCurrDateTimeStr();
    }

    /**
     * Returns the current time in a <code>String</code> object.
     * <p>
     * <i>Uses the default system settings for time.</i>
     * 
     * @return <code>String</code> object containing time in <code>HHmm</code>
     */
    public static String getCurrTimeStr() {
        return DateParser.getCurrTimeStr();
    }

    /**
     * Returns the current date in a <code>String</code>.
     * <p>
     * <i>Uses the default system settings for date.</i>
     * 
     * @return <code>String</code> object containing date in
     *         <code>dd/MM/yyyy</code>
     */
    public static String getCurrDateStr() {
        return DateParser.getCurrDateStr();
    }

    /**
     * Returns tomorrow's date in a <code>String</code>.
     * <p>
     * <i>Uses the default system settings for date.</i>
     * 
     * @return <code>String</code> object containing date in
     *         <code>dd/MM/yyyy</code>
     */
    public static String getTmrDateStr() {
        return DateParser.getTmrDateStr();
    }

    /**
     * Returns the date of the day that is <code>numDaysLater</code> days from
     * today, in a <code>String</code> object.
     * <p>
     * <i>Uses the default system settings for date.</i>
     * 
     * @return <code>String</code> object containing date in
     *         <code>dd/MM/yyyy</code>.
     */
    public static String getDateFromNowStr(int numDaysLater) {
        return DateParser.getDateFromNowStr(numDaysLater);
    }

    /**
     * Checks if the input <code>String</code> is in the accepted date format
     * <code>dd/MM/yyyy</code>.
     */
    public static boolean isValidDate(String str) {
        return DateParser.isValidDate(str);
    }

    /**
     * Checks if the input <code>String</code> is a valid time. This method
     * assumes the 24HR time format, i.e. 0000-2359, or the word format "now".
     * 
     * <p>
     * <i> The input should be an integer String. </i>
     */
    public static boolean isValidTime(String timeStr) {
        return DateParser.isValidTime(timeStr);
    }

    /**
     * Checks if the input <code>String</code> can be parsed into a
     * <code>DateTime</code> object. The date/time must be in one of four
     * formats (below).
     * <ol>
     * Formats accepted:
     * <li>Date only: dd/MM/yyyy
     * <li>Time only: HHmm
     * <li>Date and Time: dd/MM/yyyy HHmm
     * <li>Time and Date: HHmm dd/MM/yyyy
     * </ol>
     * <p>
     * Alternatives for date include "today", "tomorrow" and "tmr" Alternatives
     * for time include "now".
     */
    public static boolean isValidDateTime(String str) {
        return DateParser.isValidDateTime(str);
    }

}

	// End of segment: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\src\parser\Parser.java





	/**
	 * origin: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\test\AllTests.java
	 */

import gui.ResultGeneratorTest;
import logic.LogicUnitTest;
import logic.ProcessorTest;
import objects.ObjectsTestSuite;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;
import org.junit.runners.Suite.SuiteClasses;

import parser.TestDateParser;
import parser.TestFileParser;
import parser.TestInputParser;
import database.DatabaseTestSuite;

@RunWith(Suite.class)
@SuiteClasses({ DatabaseTestSuite.class, ObjectsTestSuite.class,
               ResultGeneratorTest.class, LogicUnitTest.class,
               ProcessorTest.class, TestDateParser.class,
               TestInputParser.class, TestFileParser.class })
public class AllTests {

}

	// End of segment: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\test\AllTests.java





	/**
	 * origin: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\test\parser\TestDateParser.java
	 */

package parser;

import static org.junit.Assert.*;

import org.junit.Test;

/**
 * Test Class for DateParser. All methods are called via the Parser class as
 * testing the facade separately will cause unnecessary double-work.
 * <p>
 * <i>Note that Assertions <strong>must</strong> be enabled for AssertionErrors
 * to be tested. Check the run configurations (of this test class or test suite)
 * and make sure it includes VM argument "-ea".</i>
 */
	// End of segment: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\test\parser\TestDateParser.java





	/**
	 * origin: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\test\parser\TestDateParser.java
	 */

public class TestDateParser {

    @Test
    public void testCurrDtGetters() {
        System.out.println("\n>> Testing Current Date/Time...");

        // Cannot use automated tests for this because current time is
        // constantly changing
        System.out.println("DateTime: " + Parser.getCurrDateTime());
        System.out.println("DateTimeStr: " + Parser.getCurrDateTimeStr());
        System.out.println("TodayDateStr: " + Parser.getCurrDateStr());
        System.out.println("TmrDateStr: " + Parser.getTmrDateStr());
        System.out.println("DateStr 7 days from now: " + Parser.getDateFromNowStr(7));
        System.out.println("DateStr 30 days from now: " + Parser.getDateFromNowStr(30));
        System.out.println("Date: " + Parser.getCurrDateStr());
        System.out.println("Time: " + Parser.getCurrTimeStr());

        System.out.println("...success!");
    }
    
    @Test
    public void testValidTime() {
        System.out.println("\n>> Testing isValidTime...");

        // Lower Boundary
        assertTrue(Parser.isValidTime("0000"));
        assertTrue(Parser.isValidTime("0001"));
        assertTrue(Parser.isValidTime("0100"));
        assertFalse(Parser.isValidTime("-001"));
        // Upper Boundary
        assertTrue(Parser.isValidTime("2359"));
        assertFalse(Parser.isValidTime("2400"));
        assertFalse(Parser.isValidTime("0060"));
        // Other cases
        assertTrue(Parser.isValidTime("now"));
        // Extreme
        assertFalse(Parser.isValidTime("9999"));
        assertFalse(Parser.isValidTime("abc"));

        System.out.println("...success!");
    }
   
    @Test
    public void testValidDate() {
        System.out.println("\n>> Testing isValidDate...");

        // Lower Boundary
        assertTrue(Parser.isValidDate("01/01/1819"));
        assertFalse(Parser.isValidDate("00/01/1819"));
        assertFalse(Parser.isValidDate("01/00/1819"));
        assertFalse(Parser.isValidDate("01/01/1818"));
        // Upper Boundary
        assertTrue(Parser.isValidDate("31/12/9999"));
        assertFalse(Parser.isValidDate("32/12/9999"));
        assertFalse(Parser.isValidDate("31/13/9999"));
        // Upper Boundary (Leap Years)
        assertTrue(Parser.isValidDate("29/02/2016"));
        assertFalse(Parser.isValidDate("30/02/2016"));
        assertTrue(Parser.isValidDate("28/02/2100"));
        assertFalse(Parser.isValidDate("29/02/2100"));
        // Word Dates
        assertTrue(Parser.isValidDate("today"));
        assertTrue(Parser.isValidDate("tomorrow"));
        assertTrue(Parser.isValidDate("tmr"));
        // Extreme
        assertFalse(Parser.isValidDate("-1/02/2016"));
        assertFalse(Parser.isValidDate("01/-2/2016"));
        assertFalse(Parser.isValidDate("01/02/-016"));
        assertFalse(Parser.isValidDate("2359"));

        System.out.println("...success!");
    }
    
    @Test
    public void testValidDateTime() {
        System.out.println("\n>> Testing isValidDateTime...");

        // Date only cases should follow isValidDate
        assertTrue(Parser.isValidDateTime("01/01/1819"));
        assertFalse(Parser.isValidDateTime("00/01/1819"));
        // Leap Years
        assertTrue(Parser.isValidDateTime("29/02/2012"));
        assertFalse(Parser.isValidDateTime("30/02/2012"));
        assertTrue(Parser.isValidDateTime("28/02/2011"));
        assertFalse(Parser.isValidDateTime("29/02/2011"));
        // Time only cases should follow isValidTime
        assertTrue(Parser.isValidDateTime("2359"));
        assertFalse(Parser.isValidDateTime("2400"));
        // Date-Time order (Valid, invalid date, invalid time)
        assertTrue(Parser.isValidDateTime("01/01/1819 0000"));
        assertFalse(Parser.isValidDateTime("01/01/1819 000"));
        assertFalse(Parser.isValidDateTime("01/00/1819 0000"));
        assertFalse(Parser.isValidDateTime("01/01/1819 2400"));
        assertTrue(Parser.isValidDateTime("today 0000"));
        // Time-Date order
        assertTrue(Parser.isValidDateTime("0000 01/01/1819"));
        assertFalse(Parser.isValidDateTime("000 01/01/1819"));
        assertFalse(Parser.isValidDateTime("0000 01/00/1819"));
        assertFalse(Parser.isValidDateTime("2400 01/01/1819"));
        assertTrue(Parser.isValidDateTime("0000 today"));
        // Extreme cases
        assertFalse(Parser.isValidDateTime("aaa"));
        assertFalse(Parser.isValidDateTime("aaaa 01/01/1819"));
        assertFalse(Parser.isValidDateTime("0000 aa/aa/aaaa"));
        
        System.out.println("...success!");
    }
    
    @Test
    public void testParseToDate() {
        System.out.println("\n>> Testing parseToDate...");

        String expected;
        String result;
        
        // null
        expected = "";
        result = Parser.parseToDateTime(null).toString();
        assertEquals(expected, result);
        // Empty
        expected = "";
        result = Parser.parseToDateTime("").toString();
        assertEquals(expected, result);
        // Valid date
        expected = "01/01/1819";
        result = Parser.parseToDateTime("01/01/1819").toString();
        assertEquals(expected, result);
        // Valid time
        expected = Parser.getCurrDateStr() + " 0000";
        result = Parser.parseToDateTime("0000").toString();
        assertEquals(expected, result);
        // Valid Date-Time
        expected = "01/01/1819 2200";
        result = Parser.parseToDateTime("01/01/1819 2200").toString();
        assertEquals(expected, result);
        // Valid Time-Date
        expected = "01/01/1819 2200";
        result = Parser.parseToDateTime("2200 01/01/1819").toString();
        assertEquals(expected, result);
        
        System.out.println("...success!");
    }
    
    @Test(expected = IllegalArgumentException.class)
    public void failParseInvalid() {
        System.out.println("\n>> Failing parseToDate with invalid input...");

        Parser.parseToDateTime("day");

        System.out.println("...success!");
    }
    
    @Test(expected = IllegalArgumentException.class)
    public void failParseInvalidDate() {
        System.out.println("\n>> Failing parseToDate with invalid date...");

        Parser.parseToDateTime("23/04/1818");

        System.out.println("...success!");
    }
    
    @Test(expected = IllegalArgumentException.class)
    public void failParseInvalidTime() {
        System.out.println("\n>> Failing parseToDate with invalid time...");

        Parser.parseToDateTime("2400");

        System.out.println("...success!");
    }
    
    // TODO: Test containsDate/Time and getFirstDate/Time methods
}

	// End of segment: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\test\parser\TestDateParser.java





	/**
	 * origin: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\test\parser\TestFileParser.java
	 */

package parser;

import static org.junit.Assert.*;

import org.junit.Test;

/**
 * Test Class for FileParser. All methods are called via the Parser class as
 * testing the facade separately will cause unnecessary double-work.
 * <p>
 * <i>Note that Assertions <strong>must</strong> be enabled for AssertionErrors
 * to be tested. Check the run configurations (of this test class or test suite)
 * and make sure it includes VM argument "-ea".</i>
 */
public class TestFileParser {

    /**
     * Tests parsing from stored data.
     * <p>
     * <i>Pre-condition: the data should have been formatted properly by
     * database.</i>
     */
    @Test
    public void testParseToTask() {
        System.out.println("\n>> Testing parseToTask()...");

        String result;
        String task;

        // Test full input
        task = Parser
                .parseToTask("do homework ### start: 20/04/2014 due: 20/04/2014 0300 "
                                     + "completed: 22/04/2014 1800 #cs2103 #todo type: done\n")
                .toString();
        result = "do homework ### start: 20/04/2014 due: 20/04/2014 0300 "
                 + "completed: 22/04/2014 1800 #cs2103 #todo type: DONE";
        assertEquals(result, task);

        // Test block task (ensure that merging BlockDate into Tasks was
        // successful)
        task = Parser
                .parseToTask("do homework ### start: 20/04/2014 0000 due: 20/04/2014 0300 "
                                     + "completed: 22/04/2014 1800 #cs2103 #todo type: block\n")
                .toString();
        result = "do homework ### start: 20/04/2014 0000 due: 20/04/2014 0300 "
                 + "completed: 22/04/2014 1800 #cs2103 #todo type: BLOCK";
        assertEquals(result, task);
        
        // Test user-input "keyword"s
        task = Parser
                .parseToTask("start: due: completed: ### start: due:  "
                                     + "completed:  ### #### type: todo\n")
                .toString();
        result = "start: due: completed: ### start:  due:  "
                 + "completed:  ### #### type: TODO";
        assertEquals(result, task);

        // Test "empty" input
        task = Parser.parseToTask("### start: due: completed: type: todo\n")
                .toString();
        result = " ### start:  due:  completed:  type: TODO";
        assertEquals(result, task);

        System.out.println("...success!");
    }

    /**
     * Missing any of the keywords, including the breakpoint "###" will cause
     * errors in the Parser.
     */
    @Test(expected = AssertionError.class)
    public void failParseMissingKeywords() {
        System.out
                .println("\n>> Failing parseToTask() with missing keywords...");

        Parser.parseToTask("do work start: 20/04/2014 due: 20/04/2014 0300 "
                           + "completed: 22/04/2014 1800 #cs2103 #todo type: done\n");

        System.out.println("...test failed!");
    }

    /**
     * Having too many keywords will create problems in the Parser.
     */
    @Test(expected = AssertionError.class)
    public void failParseExtraKeywords() {
        System.out
                .println("\n>> Failing parseToTask() with extra keywords...");

        Parser.parseToTask("work ### start: 20/04/2014 due: 20/04/2014 "
                           + "completed:  #cs2103 type: todo type: done\n");

        System.out.println("...test failed!");
    }
    
    /**
     * Having incorrect input for fields will create problems in the program itself.
     */
    @Test(expected = AssertionError.class)
    public void failParseInvalidFields() {
        System.out
                .println("\n>> Failing parseToTask() with invalid input...");

        Parser.parseToTask("work ### start: fail 20/04/2014 due: 20/04/2014 "
                           + "completed: #cs2103 type: todo\n");

        System.out.println("...test failed!");
    }
}

	// End of segment: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\test\parser\TestFileParser.java





	/**
	 * origin: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\test\parser\TestInputParser.java
	 */

package parser;

import static org.junit.Assert.*;

import org.junit.Test;

/**
 * Test Class for InputParser. All methods are called via the Parser class as
 * testing the facade separately will cause unnecessary double-work.
 * <p>
 * All test cases use ".toString()". I considered using object.equals() to test
 * assertEquals(), but did not because errors in constructors or formatting will
 * not be caught
 * <p>
 * <i>Note that Assertions <strong>must</strong> be enabled for AssertionErrors
 * to be tested. Check the run configurations (of this test class or test suite)
 * and make sure it includes VM argument "-ea".</i>
 */
public class TestInputParser {

    @Test
    public void testCommand() {
        System.out.println("\n>> Testing general inputs...");

        String result;
        String cmd;

        // Valid command with spaces in front/behind
        result = "cmdothers type: HELP";
        cmd = Parser.parse("    hELp    ").toString();
        assertEquals("Command: spaces", result, cmd);

        System.out.println("...success!");
    }

    @Test(expected = AssertionError.class)
    public void failCommandNull() {
        System.out.println("\n>> Failing general inputs with a null...");

        Parser.parse(null);

        System.out.println("...success!");
    }

    @Test(expected = IllegalArgumentException.class)
    public void failCommandSpace() {
        System.out.println("\n>> Failing general inputs with a space...");

        Parser.parse(" ");

        System.out.println("...success!");
    }

    @Test(expected = IllegalArgumentException.class)
    public void failCommandInvalid() {
        System.out.println("\n>> Failing general inputs with random words...");

        Parser.parse("that homework it's #cs2103");

        System.out.println("...success!");
    }

    @Test(expected = IllegalArgumentException.class)
    public void failCommandEmpty() {
        System.out.println("\n>> Failing general inputs with empty string...");

        Parser.parse("");

        System.out.println("...success!");
    }

    @Test
    public void testCmdAdd() {
        System.out.println("\n>> Testing Add Command...");

        String result;
        String cmd;

        // Empty Add
        result = "cmdadd name:  start:  due:  tags: []";
        cmd = Parser.parse("add").toString();
        assertEquals("Add: empty", result, cmd);

        // Basic Add ending with a parameter
        result = "cmdadd name: do homework it's cs2103 end start:  due:  tags: [#cs2103]";
        cmd = Parser.parse("add do homework it's #cs2103 cs2103 end")
                .toString();
        assertEquals("Add: simple, end param", result, cmd);

        // Full Add
        result = "cmdadd name: do start up research # due from start "
                 + "29/10/2014 soon. do quickly due thurs start: 27/10/2014 0900 "
                 + "due: 29/10/2014 tags: [#cs2103, #work]";
        cmd = Parser.parse("  add   do start #cs2103  up research # "
                                   + "due from from  27/10/2014  0900 "
                                   + "start 29/10/2014 soon. do quickly due "
                                   + "thurs end  29/10/2014 #work\n")
                .toString();
        assertEquals("Add: full", result, cmd);

        // Testing missing date in start and end
        result = "cmdadd name: do work start: " + DateParser.getCurrDateStr() +
                 " 0300 due: " + DateParser.getCurrDateStr() + " 0600 tags: []";
        cmd = Parser.parse("add do work from 0300 to 0600\n").toString();
        assertEquals("Add: date filling", result, cmd);

        // Testing missing date in start with reordering
        result = "cmdadd name: do work start: 29/10/2014 0300 due: 29/10/2014 0600 tags: []";
        cmd = Parser.parse("add do work from 29/10/2014 0600 due 0300\n")
                .toString();
        assertEquals("Add: 1 missing date, reordering", result, cmd);

        // Today/Tomorrow
        result = "cmdadd name: do work start: " + DateParser.getCurrDateStr() +
                 " 0600 due: " + DateParser.getTmrDateStr() + " 0800 tags: []";
        cmd = Parser.parse("add do work from today 0600 to tomorrow 0800\n")
                .toString();
        assertEquals("Add: today/tomorrow", result, cmd);

        System.out.println("...success!");
    }

    @Test
    public void testCmdEdit() {
        System.out.println("\n>> Testing Edit Command...");

        String result;
        String cmd;

        // Edit with only id
        result = "cmdedit id: 1 name:  start:  due:  tags: [] delete: []";
        cmd = Parser.parse("edit 1").toString();
        assertEquals("Edit: id only", result, cmd);

        // Full Edit with repeated parameters and consecutive parameters
        result = "cmdedit id: 3 name: do homework due soon for CS2103 project " +
                "start: 22/04/2014 1200 due: 23/04/2014 tags: [#CS2103] delete: [due, start]";
        cmd = Parser
                .parse(" edIt 3 do  #CS2103 homework due  DUE  23/04/2014  start   22/04/2014   1200 "
                               + "soon for CS2103 delete  end  delete frOM project")
                .toString();
        assertEquals("Edit: full, repeated param, consecutive param", result,
                     cmd);

        // Testing delete parameter
        result = "cmdedit id: 4 name: do homework delete tags by start delete " +
                "start:  due:  tags: [] delete: [start, due, tags]";
        cmd = Parser
                .parse("edit 4 do homework delete start delete to delete tags delete tags by start delete")
                .toString();
        assertEquals("Edit: delete param", result, cmd);

        System.out.println("...success!");
    }

    @Test(expected = IllegalArgumentException.class)
    public void failCmdEditEmpty() {
        System.out.println("\n>> Failing Edit Command with an empty String...");

        // Empty (invalid), mixed caps
        Parser.parse("eDIt");

        System.out.println("...success!");
    }

    @Test(expected = IllegalArgumentException.class)
    public void failCmdEditID() {
        System.out.println("\n>> Failing Edit Command with an invalid ID...");

        // Edit with words but no id
        Parser.parse("edit one two");

        System.out.println("...success!");
    }

    @Test
    public void testCmdDelete() {
        System.out.println("\n>> Testing Delete Command...");

        String result;
        String cmd;

        // Test possible input parameters
        String[] deleteParams = new String[] { "all", "search", "done" };

        for (String p : deleteParams) {
            result = "cmddelete rangetype: " + p + " id: ";
            cmd = Parser.parse("delete " + p).toString();
            assertEquals("Delete: parameter", result, cmd);
        }

        // Delete by ID
        result = "cmddelete rangetype: id id: 11";
        cmd = Parser.parse("delete 11").toString();
        assertEquals("Delete: id", result, cmd);

        // Delete with mixed caps
        result = "cmddelete rangetype: done id: ";
        cmd = Parser.parse("deLEte dONe").toString();
        assertEquals("Delete: mixed caps (done)", result, cmd);

        System.out.println("...success!");
    }

    @Test(expected = IllegalArgumentException.class)
    public void failCmdDeleteEmpty() {
        System.out.println("\n>> Failing Delete Command with just spaces...");

        Parser.parse("delete    ");

        System.out.println("...success!");
    }

    @Test(expected = IllegalArgumentException.class)
    public void failCmdDeleteInvalid() {
        System.out
                .println("\n>> Failing Delete Command with invalid parameter...");

        Parser.parse("delete days");

        System.out.println("...success!");
    }

    @Test
    public void testCmdRestore() {
        System.out.println("\n>> Testing Restore Command...");

        String result;
        String cmd;

        // Restore by ID
        result = "cmdrestore rangetype: id id: 1";
        cmd = Parser.parse("   restore   1     ").toString();
        assertEquals("Restore: id, spaces", result, cmd);

        System.out.println("...success!");
    }

    @Test(expected = IllegalArgumentException.class)
    public void failCmdRestoreEmpty() {
        System.out.println("\n>> Failing Restore Command with just spaces...");

        // Empty (invalid), mixed caps
        Parser.parse("restore");

        System.out.println("...success!");
    }

    @Test(expected = IllegalArgumentException.class)
    public void failCmdRestoreInvalid() {
        System.out
                .println("\n>> Failing Restore Command with an invalid parameter input...");

        // Empty (invalid), mixed caps
        Parser.parse("restore b");

        System.out.println("...success!");
    }

    @Test
    public void testCmdDisplay() {
        System.out.println("\n>> Testing Display Command...");

        String result;
        String cmd;

        // Empty display (displays todo tasks)
        result = "cmddisplay rangetype: all id: ";
        cmd = Parser.parse("display").toString();
        assertEquals("Display: empty", result, cmd);

        // Empty display with spaces
        result = "cmddisplay rangetype: all id: ";
        cmd = Parser.parse("display           ").toString();
        assertEquals("Display: empty, spaces", result, cmd);

        // Test possible input parameters
        String[] displayParams = new String[] { "all", "block", "search",
                                               "done", "deleted" };

        for (String p : displayParams) {
            result = "cmddisplay rangetype: " + p + " id: ";
            cmd = Parser.parse("display " + p).toString();
            assertEquals("Display: parameter", result, cmd);
        }

        // Words after, mixed caps, spaces
        result = "cmddisplay rangetype: block id: ";
        cmd = Parser.parse("    disPLay    bLOck    a    b   c").toString();
        assertEquals("Display: block, extra, caps, spaces", result, cmd);

        // Display by ID
        result = "cmddisplay rangetype: id id: 2";
        cmd = Parser.parse("display 2").toString();
        assertEquals("Display: ID", result, cmd);

        // Switch 'display' with 'show'
        result = "cmddisplay rangetype: id id: 2";
        cmd = Parser.parse("show 2").toString();
        assertEquals("Display: show", result, cmd);

        System.out.println("...success!");
    }

    @Test(expected = IllegalArgumentException.class)
    public void failCmdDisplayInvalid() {
        System.out
                .println("\n>> Failing Display Command with an invalid input...");

        Parser.parse("display blocka");

        System.out.println("...success!");
    }

    @Test
    public void testCmdSearch() {
        System.out.println("\n>> Testing Search Command...");

        String result;
        String cmd;

        // Full search: mixed caps command, status, date, keywords, tags
        result = "cmdsearch status: all date: 23/04/2014 tags: [#done, #cS2103] " +
                "keywords: [done, 23/04/201, homework, late]";
        cmd = Parser
                .parse("  seARch    ALL  done 23/04/2014 23/04/201 homework #done #cS2103 late ")
                .toString();
        assertEquals("Search: status, full combination", result, cmd);

        // Search without status
        result = "cmdsearch status: todo date: 23/04/2014 tags: [#cS2103] keywords: [homework]";
        cmd = Parser.parse(" seARch   23/04/2014 homework #cS2103").toString();
        assertEquals("Search: no status", result, cmd);

        System.out.println("...success!");
    }

    @Test(expected = IllegalArgumentException.class)
    public void failCmdSearchEmpty() {
        System.out.println("\n>> Failing Search Command with just spaces...");

        Parser.parse("search      ");

        System.out.println("...success!");
    }

    @Test(expected = IllegalArgumentException.class)
    public void failCmdSearchDates() {
        System.out
                .println("\n>> Failing Search Command with multiple dates...");

        Parser.parse("search 23/04/2014 24/04/2014");

        System.out.println("...success!");
    }

    @Test
    public void testCmdDone() {
        System.out.println("\n>> Testing Done Command...");

        String result;
        String cmd;

        // Done all, extra spaces
        result = "cmddone rangetype: all id:  date: ";
        cmd = Parser.parse("done all   ").toString();
        assertEquals("Done: all, spaces", result, cmd);

        // Done by id, extra words after
        result = "cmddone rangetype: id id: 2 date: ";
        cmd = Parser.parse("done 2 hurrah").toString();
        assertEquals("Done: id, extra words", result, cmd);

        // Done by date
        result = "cmddone rangetype: date id:  date: 23/04/2014";
        cmd = Parser.parse("done 23/4").toString();
        assertEquals("Done: date", result, cmd);

        System.out.println("...success!");

    }

    @Test(expected = IllegalArgumentException.class)
    public void failCmdDoneEmpty() {
        System.out.println("\n>> Failing Done Command with spaces...");

        Parser.parse("done      ");

        System.out.println("...success!");
    }

    @Test(expected = IllegalArgumentException.class)
    public void failCmdDoneInvalid() {
        System.out
                .println("\n>> Failing Done Command with an invalid parameter...");

        Parser.parse("done this");

        System.out.println("...success!");
    }

    @Test
    public void testCmdTodo() {
        System.out.println("\n>> Testing Todo Command...");

        String result;
        String cmd;

        // Todo id, extra numbers/words
        result = "cmdtodo rangeType: id id: 1 date: ";
        cmd = Parser.parse("todo 1 3 four").toString();
        assertEquals("Todo: id, extra", result, cmd);

        // Todo last
        result = "cmdtodo rangeType: last id:  date: ";
        cmd = Parser.parse("todo last").toString();
        assertEquals("Todo: last", result, cmd);

        System.out.println("...success!");
    }

    @Test(expected = IllegalArgumentException.class)
    public void failCmdTodoEmpty() {
        System.out.println("\n>> Failing Todo Command with spaces...");

        Parser.parse("tODo      ");

        System.out.println("...success!");
    }

    @Test(expected = IllegalArgumentException.class)
    public void failCmdTodoInvalid() {
        System.out
                .println("\n>> Failing Todo Command with an invalid parameter...");

        Parser.parse("todo one");

        System.out.println("...success!");
    }

    @Test
    public void testCmdBlock() {
        System.out.println("\n>> Testing Block Command...");
        System.out.println("(Note that the date for time-only cases is " +
                           DateParser.getCurrDateStr() + ")");

        String result;
        String cmd;

        // TODO: is support for today/tomorrow required?

        // 1/4: Single date
        result = "cmdblock name:  from: 23/04/2014 0000 to: 23/04/2014 2359 tags: []";
        cmd = Parser.parse("block from 23/04/2014").toString();
        assertEquals("Block: single date", result, cmd);

        // 1/4: Single time [Note that date is generated by current date]
        result = "cmdblock name:  from: " + DateParser.getCurrDateStr() +
                 " 0000 to: " + DateParser.getCurrDateStr() + " 0800 tags: []";
        cmd = Parser.parse("bLOck to 0800").toString();
        assertEquals("Block: single time", result, cmd);

        // 2/4: First date and time
        result = "cmdblock name:  from: 23/04/2014 0600 to: 23/04/2014 2359 tags: []";
        cmd = Parser.parse("bLOck from 0600 23/4").toString();
        assertEquals("Block: single date/time", result, cmd);

        // 2/4: Latter Single date and time
        result = "cmdblock name:  from: 23/04/2014 0000 to: 23/04/2014 0600 tags: []";
        cmd = Parser.parse("bLOck to 0600 23/04/2014").toString();
        assertEquals("Block: single date/time, to", result, cmd);

        // 2/4: Date-only range
        result = "cmdblock name:  from: 23/04/2014 0000 to: 25/04/2014 2359 tags: []";
        cmd = Parser.parse("bLOck from 23/04/2014 to 25/04/2014").toString();
        assertEquals("Block: date range", result, cmd);

        // 2/4: Date-only range with swap
        result = "cmdblock name:  from: 23/04/2014 0000 to: 25/04/2014 2359 tags: []";
        cmd = Parser.parse("bLOck from 25/04/2014 to 23/04/2014").toString();
        assertEquals("Block: date range, swap", result, cmd);

        // 2/4: Time-only range [Note that date is generated by current date]
        result = "cmdblock name:  from: " + DateParser.getCurrDateStr() +
                 " 0300 to: " + DateParser.getCurrDateStr() + " 0600 tags: []";
        cmd = Parser.parse("bLOck from 0300 to 0600").toString();
        assertEquals("Block: time range", result, cmd);

        // 2/4: Time-only range with swap
        result = "cmdblock name:  from: " + DateParser.getCurrDateStr() +
                 " 0300 to: " + DateParser.getCurrDateStr() + " 0600 tags: []";
        cmd = Parser.parse("bLOck from 0600 to 0300").toString();
        assertEquals("Block: time range, swap", result, cmd);

        // 2/4: 1st time 2nd date
        result = "cmdblock name:  from: 23/04/2014 0000 to: 23/04/2014 0600 tags: []";
        cmd = Parser.parse("bLOck from 23/4 to 0600").toString();
        assertEquals("Block: 1st time, 2nd date", result, cmd);

        // 2/4: 2nd time 1st date
        result = "cmdblock name:  from: 23/04/2014 0600 to: 23/04/2014 2359 tags: []";
        cmd = Parser.parse("bLOck from 0600 to 23/4").toString();
        assertEquals("Block: 2nd time, 1st date", result, cmd);

        // 3/4: missing 1st time, swap
        result = "cmdblock name:  from: 24/04/2014 0600 to: 23/04/2018 2359 tags: []";
        cmd = Parser.parse("bLOck from 23/04/2018 to 24/04/2014 0600")
                .toString();
        assertEquals("Block: 3/4, no 1st time", result, cmd);

        // 3/4: missing 2nd time, time-date order
        result = "cmdblock name:  from: 23/04/2014 0600 to: 24/04/2014 2359 tags: []";
        cmd = Parser.parse("bLOck from 0600 23/4 to 24/4").toString();
        assertEquals("Block: 3/4, no 2nd time, time-date order", result, cmd);

        // 3/4: missing 1st date, time-date order, swap
        result = "cmdblock name:  from: 24/04/2014 0300 to: 24/04/2014 0600 tags: []";
        cmd = Parser.parse("bLOck from 0600 to 0300 24/04/2014").toString();
        assertEquals("Block: 3/4, no 1st date, swap, time-date order", result,
                     cmd);

        // 3/4: missing 2nd date
        result = "cmdblock name:  from: 24/04/2014 0300 to: 24/04/2014 0600 tags: []";
        cmd = Parser.parse("bLOck from 24/04/2014 0300 to 0600").toString();
        assertEquals("Block: 3/4, no 2nd date", result, cmd);

        // 4/4: swap with spaces, description and tags
        result = "cmdblock name: project meeting from: 23/04/2014 0600 to: 24/04/2014 0300 tags: []";
        cmd = Parser
                .parse("   bLOck  project  meeting   from  24/04/2014    0300 to  23/04/2014   0600")
                .toString();
        assertEquals("Block: 4/4, swap, extra spaces", result, cmd);

        System.out.println("...success!");
    }

    @Test(expected = IllegalArgumentException.class)
    public void failCmdBlockEmpty() {
        System.out
                .println("\n>> Failing Block Command with an empty String...");

        // Empty (invalid), mixed caps
        Parser.parse("bLOck");

        System.out.println("...success!");
    }

    @Test(expected = IllegalArgumentException.class)
    public void failCmdBlockSpaces() {
        System.out.println("\n>> Failing Block Command with just spaces...");

        // Spaces
        Parser.parse("block      ");

        System.out.println("...success!");
    }

    @Test
    public void testCmdOthers() {
        System.out
                .println("\n>> Testing Undo, Redo, Help, Reset, Exit Commands...");

        String result;
        String cmd;

        // Undo: caps, spaces
        result = "cmdothers type: UNDO";
        cmd = Parser.parse("uNDo      ").toString();
        assertEquals("Undo: mixed caps, spaces", result, cmd);

        // Redo: caps, spaces
        result = "cmdothers type: REDO";
        cmd = Parser.parse("rEdO      ").toString();
        assertEquals("Redo: mixed caps, spaces", result, cmd);

        // Exit: caps, spaces
        result = "cmdothers type: EXIT";
        cmd = Parser.parse("exIT      ").toString();
        assertEquals("Exit: mixed caps, spaces", result, cmd);

        // Reset
        result = "cmdothers type: RESET";
        cmd = Parser.parse("reset").toString();
        assertEquals("Reset: simple", result, cmd);

        // Help: caps, spaces, extra words
        result = "cmdothers type: HELP";
        cmd = Parser.parse("  heLP me      ").toString();
        assertEquals("Help: caps, spaces, extra words", result, cmd);

        System.out.println("...success!");
    }
}

	// End of segment: C:\Users\Yao Xiang\Desktop\CS2103T_PROJECT\main\test\parser\TestInputParser.java





